<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OMNeT++ Simulation Library: String Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OMNeT++ Simulation Library
   &#160;<span id="projectnumber">6.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__StringFunctions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">String Functions</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Miscellaneous string-related utility functions. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad71987187ec298ccaf34333675ff51e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gad71987187ec298ccaf34333675ff51e8">opp_isempty</a> (const char *s)</td></tr>
<tr class="memdesc:gad71987187ec298ccaf34333675ff51e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string is nullptr or has zero length.  <a href="group__StringFunctions.html#gad71987187ec298ccaf34333675ff51e8">More...</a><br /></td></tr>
<tr class="separator:gad71987187ec298ccaf34333675ff51e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga951c9575f8fe8e4db1b42a27ae0c0094"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga951c9575f8fe8e4db1b42a27ae0c0094">opp_nulltoempty</a> (const char *s)</td></tr>
<tr class="memdesc:ga951c9575f8fe8e4db1b42a27ae0c0094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer passed as argument unchanged, except that if it was nullptr, it returns a pointer to a null string ("").  <a href="group__StringFunctions.html#ga951c9575f8fe8e4db1b42a27ae0c0094">More...</a><br /></td></tr>
<tr class="separator:ga951c9575f8fe8e4db1b42a27ae0c0094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e5c4983b9967fe2ddcac3d2e4455d3a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga6e5c4983b9967fe2ddcac3d2e4455d3a">opp_emptytodefault</a> (const char *s, const char *defaultString)</td></tr>
<tr class="memdesc:ga6e5c4983b9967fe2ddcac3d2e4455d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer passed as argument unchanged, except that if it was empty, it returns the second argument.  <a href="group__StringFunctions.html#ga6e5c4983b9967fe2ddcac3d2e4455d3a">More...</a><br /></td></tr>
<tr class="separator:ga6e5c4983b9967fe2ddcac3d2e4455d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbe853f05a2e0646a92dee806ec7e5ad"><td class="memItemLeft" align="right" valign="top">SIM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gadbe853f05a2e0646a92dee806ec7e5ad">opp_isblank</a> (const char *txt)</td></tr>
<tr class="memdesc:gadbe853f05a2e0646a92dee806ec7e5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string only contains whitespace.  <a href="group__StringFunctions.html#gadbe853f05a2e0646a92dee806ec7e5ad">More...</a><br /></td></tr>
<tr class="separator:gadbe853f05a2e0646a92dee806ec7e5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d37626062f2bb2cf6aa6395c0b03f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gac5d37626062f2bb2cf6aa6395c0b03f5">opp_strlen</a> (const char *s)</td></tr>
<tr class="memdesc:gac5d37626062f2bb2cf6aa6395c0b03f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the standard strlen() function, except that does not crash on nullptr but returns 0.  <a href="group__StringFunctions.html#gac5d37626062f2bb2cf6aa6395c0b03f5">More...</a><br /></td></tr>
<tr class="separator:gac5d37626062f2bb2cf6aa6395c0b03f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga952348557633594f6aafefb765e903b8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga952348557633594f6aafefb765e903b8">opp_strdup</a> (const char *s)</td></tr>
<tr class="memdesc:ga952348557633594f6aafefb765e903b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates the string, using <code>new char[]</code>. For nullptr and empty strings it returns nullptr.  <a href="group__StringFunctions.html#ga952348557633594f6aafefb765e903b8">More...</a><br /></td></tr>
<tr class="separator:ga952348557633594f6aafefb765e903b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a17c1ab20b3f51d5d9161390addc7a8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga2a17c1ab20b3f51d5d9161390addc7a8">opp_strcpy</a> (char *s1, const char *s2)</td></tr>
<tr class="memdesc:ga2a17c1ab20b3f51d5d9161390addc7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the standard strcpy() function, except that nullptr in the second argument is treated as a pointer to an empty string ("").  <a href="group__StringFunctions.html#ga2a17c1ab20b3f51d5d9161390addc7a8">More...</a><br /></td></tr>
<tr class="separator:ga2a17c1ab20b3f51d5d9161390addc7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7992873d177e68c338886da35078781"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gac7992873d177e68c338886da35078781">opp_strcmp</a> (const char *s1, const char *s2)</td></tr>
<tr class="memdesc:gac7992873d177e68c338886da35078781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the standard strcmp() function, except that nullptr is treated exactly as an empty string ("").  <a href="group__StringFunctions.html#gac7992873d177e68c338886da35078781">More...</a><br /></td></tr>
<tr class="separator:gac7992873d177e68c338886da35078781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga735e27c5ec595ea46855842d1ed82966"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga735e27c5ec595ea46855842d1ed82966">opp_trim</a> (const std::string &amp;text)</td></tr>
<tr class="memdesc:ga735e27c5ec595ea46855842d1ed82966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any leading and trailing whitespace.  <a href="group__StringFunctions.html#ga735e27c5ec595ea46855842d1ed82966">More...</a><br /></td></tr>
<tr class="separator:ga735e27c5ec595ea46855842d1ed82966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46437ddb528048851ff78a55fda7fd0b"><td class="memItemLeft" align="right" valign="top">SIM_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga46437ddb528048851ff78a55fda7fd0b">opp_strprettytrunc</a> (char *dest, const char *src, unsigned maxlen)</td></tr>
<tr class="memdesc:ga46437ddb528048851ff78a55fda7fd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies src string into dest, and if its length would exceed maxlen, it is truncated with an ellipsis. For example, <code>opp_strprettytrunc(buf, "long-long",6)</code> yields <code>"lon..."</code>.  <a href="group__StringFunctions.html#ga46437ddb528048851ff78a55fda7fd0b">More...</a><br /></td></tr>
<tr class="separator:ga46437ddb528048851ff78a55fda7fd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dacc92d54b7cbafad7ca28759f847e3"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga6dacc92d54b7cbafad7ca28759f847e3">opp_stringf</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:ga6dacc92d54b7cbafad7ca28759f847e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string using printf-like formatting. Allocates storage dynamically.  <a href="group__StringFunctions.html#ga6dacc92d54b7cbafad7ca28759f847e3">More...</a><br /></td></tr>
<tr class="separator:ga6dacc92d54b7cbafad7ca28759f847e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66e6cf98a49b9081da46c90ec6dc0bf7"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga66e6cf98a49b9081da46c90ec6dc0bf7">opp_vstringf</a> (const char *fmt, va_list &amp;args)</td></tr>
<tr class="memdesc:ga66e6cf98a49b9081da46c90ec6dc0bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a string using printf-like formatting. Allocates storage dynamically.  <a href="group__StringFunctions.html#ga66e6cf98a49b9081da46c90ec6dc0bf7">More...</a><br /></td></tr>
<tr class="separator:ga66e6cf98a49b9081da46c90ec6dc0bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e2c73bb1375dd511c9049f8d34b6583"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga9e2c73bb1375dd511c9049f8d34b6583">opp_replacesubstring</a> (const std::string &amp;text, const std::string &amp;substring, const std::string &amp;replacement, bool replaceAll)</td></tr>
<tr class="memdesc:ga9e2c73bb1375dd511c9049f8d34b6583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs find/replace within a string.  <a href="group__StringFunctions.html#ga9e2c73bb1375dd511c9049f8d34b6583">More...</a><br /></td></tr>
<tr class="separator:ga9e2c73bb1375dd511c9049f8d34b6583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab32c96ea56086b02c1b7d8e4b8ec6d0"><td class="memItemLeft" align="right" valign="top">SIM_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gaab32c96ea56086b02c1b7d8e4b8ec6d0">opp_splitandtrim</a> (const std::string &amp;text)</td></tr>
<tr class="memdesc:gaab32c96ea56086b02c1b7d8e4b8ec6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into parts by whitespace sequences. Returned items will have no leading or trailing whitespace. Returns an empty array if the input string is empty or only contains whitespace.  <a href="group__StringFunctions.html#gaab32c96ea56086b02c1b7d8e4b8ec6d0">More...</a><br /></td></tr>
<tr class="separator:gaab32c96ea56086b02c1b7d8e4b8ec6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4cf0fbabebf36ca6b42e21c2df0c256"><td class="memItemLeft" align="right" valign="top">SIM_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gab4cf0fbabebf36ca6b42e21c2df0c256">opp_split</a> (const std::string &amp;text, const std::string &amp;separator)</td></tr>
<tr class="memdesc:gab4cf0fbabebf36ca6b42e21c2df0c256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into parts separated by the given separator. If the input string is empty, it returns an empty array. Otherwise, it returns exactly #separators+1 items. The separator cannot be empty.  <a href="group__StringFunctions.html#gab4cf0fbabebf36ca6b42e21c2df0c256">More...</a><br /></td></tr>
<tr class="separator:gab4cf0fbabebf36ca6b42e21c2df0c256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga182ca639f566554f9f3ad569db526f16"><td class="memItemLeft" align="right" valign="top">SIM_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga182ca639f566554f9f3ad569db526f16">opp_splitandtrim</a> (const std::string &amp;text, const std::string &amp;separator)</td></tr>
<tr class="memdesc:ga182ca639f566554f9f3ad569db526f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into parts separated by the given separator, trimming each item of whitespace. Returns an empty array if the input string doesn't contain anything but whitespace. The separator cannot be empty.  <a href="group__StringFunctions.html#ga182ca639f566554f9f3ad569db526f16">More...</a><br /></td></tr>
<tr class="separator:ga182ca639f566554f9f3ad569db526f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6906bf6d09624b52903983a729c94384"><td class="memItemLeft" align="right" valign="top">SIM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga6906bf6d09624b52903983a729c94384">opp_stringbeginswith</a> (const char *s, const char *prefix)</td></tr>
<tr class="memdesc:ga6906bf6d09624b52903983a729c94384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the first string begins with the second string.  <a href="group__StringFunctions.html#ga6906bf6d09624b52903983a729c94384">More...</a><br /></td></tr>
<tr class="separator:ga6906bf6d09624b52903983a729c94384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4bcbc00e314d5e89f471f9b81ee56d3"><td class="memItemLeft" align="right" valign="top">SIM_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gaa4bcbc00e314d5e89f471f9b81ee56d3">opp_stringendswith</a> (const char *s, const char *ending)</td></tr>
<tr class="memdesc:gaa4bcbc00e314d5e89f471f9b81ee56d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the first string ends in the second string.  <a href="group__StringFunctions.html#gaa4bcbc00e314d5e89f471f9b81ee56d3">More...</a><br /></td></tr>
<tr class="separator:gaa4bcbc00e314d5e89f471f9b81ee56d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b0e66b1e0b0b1d9c307af789581c0cc"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga0b0e66b1e0b0b1d9c307af789581c0cc">opp_substringbefore</a> (const std::string &amp;str, const std::string &amp;substr)</td></tr>
<tr class="memdesc:ga0b0e66b1e0b0b1d9c307af789581c0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the substring up to the first occurrence of the given substring, or "".  <a href="group__StringFunctions.html#ga0b0e66b1e0b0b1d9c307af789581c0cc">More...</a><br /></td></tr>
<tr class="separator:ga0b0e66b1e0b0b1d9c307af789581c0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8654572f4cc9b5503ad8a9c0262c28ba"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga8654572f4cc9b5503ad8a9c0262c28ba">opp_substringafter</a> (const std::string &amp;str, const std::string &amp;substr)</td></tr>
<tr class="memdesc:ga8654572f4cc9b5503ad8a9c0262c28ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the substring after the first occurrence of the given substring, or "".  <a href="group__StringFunctions.html#ga8654572f4cc9b5503ad8a9c0262c28ba">More...</a><br /></td></tr>
<tr class="separator:ga8654572f4cc9b5503ad8a9c0262c28ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2f9943819c4a05d300f20a6bba4942"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga2d2f9943819c4a05d300f20a6bba4942">opp_substringbeforelast</a> (const std::string &amp;str, const std::string &amp;substr)</td></tr>
<tr class="memdesc:ga2d2f9943819c4a05d300f20a6bba4942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the substring up to the last occurrence of the given substring, or "".  <a href="group__StringFunctions.html#ga2d2f9943819c4a05d300f20a6bba4942">More...</a><br /></td></tr>
<tr class="separator:ga2d2f9943819c4a05d300f20a6bba4942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacef29cbc82992df1f61fc81584c9a534"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gacef29cbc82992df1f61fc81584c9a534">opp_substringafterlast</a> (const std::string &amp;str, const std::string &amp;substr)</td></tr>
<tr class="memdesc:gacef29cbc82992df1f61fc81584c9a534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the substring after the last occurrence of the given substring, or "".  <a href="group__StringFunctions.html#gacef29cbc82992df1f61fc81584c9a534">More...</a><br /></td></tr>
<tr class="separator:gacef29cbc82992df1f61fc81584c9a534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a0bc1a9a28acb13bfcfc72497804d8"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gaf6a0bc1a9a28acb13bfcfc72497804d8">opp_removestart</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:gaf6a0bc1a9a28acb13bfcfc72497804d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the prefix if the s string starts with it, otherwise return the string unchanged.  <a href="group__StringFunctions.html#gaf6a0bc1a9a28acb13bfcfc72497804d8">More...</a><br /></td></tr>
<tr class="separator:gaf6a0bc1a9a28acb13bfcfc72497804d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c866b0a1188f316c80fa86c1d85e466"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga7c866b0a1188f316c80fa86c1d85e466">opp_removeend</a> (const std::string &amp;str, const std::string &amp;end)</td></tr>
<tr class="memdesc:ga7c866b0a1188f316c80fa86c1d85e466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given end string if the s string ends with it, otherwise return the string unchanged.  <a href="group__StringFunctions.html#ga7c866b0a1188f316c80fa86c1d85e466">More...</a><br /></td></tr>
<tr class="separator:ga7c866b0a1188f316c80fa86c1d85e466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga903130ddaf3e5c86b7dba1cb3bbfc69b"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga903130ddaf3e5c86b7dba1cb3bbfc69b">opp_strlower</a> (const char *s)</td></tr>
<tr class="memdesc:ga903130ddaf3e5c86b7dba1cb3bbfc69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the string to lower case, and returns the result.  <a href="group__StringFunctions.html#ga903130ddaf3e5c86b7dba1cb3bbfc69b">More...</a><br /></td></tr>
<tr class="separator:ga903130ddaf3e5c86b7dba1cb3bbfc69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadffe270826254f3958a942d619c20f2f"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gadffe270826254f3958a942d619c20f2f">opp_strupper</a> (const char *s)</td></tr>
<tr class="memdesc:gadffe270826254f3958a942d619c20f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the string to upper case, and returns the result.  <a href="group__StringFunctions.html#gadffe270826254f3958a942d619c20f2f">More...</a><br /></td></tr>
<tr class="separator:gadffe270826254f3958a942d619c20f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9a82ab8007ff491ef98f4022bd927b8"><td class="memItemLeft" align="right" valign="top">const SIM_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gad9a82ab8007ff491ef98f4022bd927b8">opp_strnistr</a> (const char *haystack, const char *needle, int n, bool caseSensitive)</td></tr>
<tr class="memdesc:gad9a82ab8007ff491ef98f4022bd927b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the first occurrence of the nul-terminated string needle in the string haystack, where not more than n characters are searched. Characters that appear after a '\0' character are not searched.  <a href="group__StringFunctions.html#gad9a82ab8007ff491ef98f4022bd927b8">More...</a><br /></td></tr>
<tr class="separator:gad9a82ab8007ff491ef98f4022bd927b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d108163546bdfe10a30659151cc207e"><td class="memItemLeft" align="right" valign="top">SIM_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga8d108163546bdfe10a30659151cc207e">opp_strdictcmp</a> (const char *s1, const char *s2)</td></tr>
<tr class="memdesc:ga8d108163546bdfe10a30659151cc207e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary-compare two strings, the main difference from strcasecmp() being that integers embedded in the strings are compared in numerical order.  <a href="group__StringFunctions.html#ga8d108163546bdfe10a30659151cc207e">More...</a><br /></td></tr>
<tr class="separator:ga8d108163546bdfe10a30659151cc207e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga890fa100e722c6fb0c2dac45027968ce"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga890fa100e722c6fb0c2dac45027968ce">opp_join</a> (const char *separator, const char *s1, const char *s2)</td></tr>
<tr class="memdesc:ga890fa100e722c6fb0c2dac45027968ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">If either s1 or s2 is empty, returns the other one, otherwise returns s1 + separator + s2.  <a href="group__StringFunctions.html#ga890fa100e722c6fb0c2dac45027968ce">More...</a><br /></td></tr>
<tr class="separator:ga890fa100e722c6fb0c2dac45027968ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b3b9fe744b5f706f499bb22cd3b57a1"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga5b3b9fe744b5f706f499bb22cd3b57a1">opp_join</a> (const char *separator, const std::string &amp;s1, const std::string &amp;s2)</td></tr>
<tr class="memdesc:ga5b3b9fe744b5f706f499bb22cd3b57a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If either s1 or s2 is empty, returns the other one, otherwise returns s1 + separator + s2.  <a href="group__StringFunctions.html#ga5b3b9fe744b5f706f499bb22cd3b57a1">More...</a><br /></td></tr>
<tr class="separator:ga5b3b9fe744b5f706f499bb22cd3b57a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10eade29b929be0303af7b71f065206e"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga10eade29b929be0303af7b71f065206e">opp_join</a> (const char **strings, const char *separator, bool skipEmpty=false, char quoteChar=0)</td></tr>
<tr class="memdesc:ga10eade29b929be0303af7b71f065206e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate the strings passed in the nullptr-terminated const char * array, using the given separator and putting each item between quoteChars unless it is '\0'. Empty elements are optionally skipped.  <a href="group__StringFunctions.html#ga10eade29b929be0303af7b71f065206e">More...</a><br /></td></tr>
<tr class="separator:ga10eade29b929be0303af7b71f065206e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1e741f43ea4c1fda8f239d42ff1a5f9"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gad1e741f43ea4c1fda8f239d42ff1a5f9">opp_join</a> (const char **strings, int n, const char *separator, bool skipEmpty=false, char quoteChar=0)</td></tr>
<tr class="memdesc:gad1e741f43ea4c1fda8f239d42ff1a5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate the strings passed in the const char * array of size n, using the given separator and putting each item between quoteChars unless it is '\0'. Empty elements are optionally skipped.  <a href="group__StringFunctions.html#gad1e741f43ea4c1fda8f239d42ff1a5f9">More...</a><br /></td></tr>
<tr class="separator:gad1e741f43ea4c1fda8f239d42ff1a5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba29e0e1269a81a4a77c85efc28a4e5"><td class="memItemLeft" align="right" valign="top">SIM_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga1ba29e0e1269a81a4a77c85efc28a4e5">opp_join</a> (const std::vector&lt; std::string &gt; &amp;strings, const char *separator, bool skipEmpty=false, char quoteChar=0)</td></tr>
<tr class="memdesc:ga1ba29e0e1269a81a4a77c85efc28a4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate the strings passed in the vector, using the given separator, and putting each item between quoteChars unless it is '\0'. Empty elements are optionally skipped.  <a href="group__StringFunctions.html#ga1ba29e0e1269a81a4a77c85efc28a4e5">More...</a><br /></td></tr>
<tr class="separator:ga1ba29e0e1269a81a4a77c85efc28a4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga446dacb337a9e200679cc387d979f631"><td class="memItemLeft" align="right" valign="top">SIM_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga446dacb337a9e200679cc387d979f631">opp_itoa</a> (char *buf, int d)</td></tr>
<tr class="memdesc:ga446dacb337a9e200679cc387d979f631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the d integer into the given buffer, then returns the buffer pointer.  <a href="group__StringFunctions.html#ga446dacb337a9e200679cc387d979f631">More...</a><br /></td></tr>
<tr class="separator:ga446dacb337a9e200679cc387d979f631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a8c0b13abed297a5c8cb3f1145fa289"><td class="memItemLeft" align="right" valign="top">SIM_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga5a8c0b13abed297a5c8cb3f1145fa289">opp_ltoa</a> (char *buf, long d)</td></tr>
<tr class="memdesc:ga5a8c0b13abed297a5c8cb3f1145fa289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the d integer into the given buffer, then returns the buffer pointer.  <a href="group__StringFunctions.html#ga5a8c0b13abed297a5c8cb3f1145fa289">More...</a><br /></td></tr>
<tr class="separator:ga5a8c0b13abed297a5c8cb3f1145fa289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7667e67a1537e12c04dbef77d69cf5d"><td class="memItemLeft" align="right" valign="top">SIM_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gab7667e67a1537e12c04dbef77d69cf5d">opp_i64toa</a> (char *buf, int64_t d)</td></tr>
<tr class="memdesc:gab7667e67a1537e12c04dbef77d69cf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the d integer into the given buffer, then returns the buffer pointer.  <a href="group__StringFunctions.html#gab7667e67a1537e12c04dbef77d69cf5d">More...</a><br /></td></tr>
<tr class="separator:gab7667e67a1537e12c04dbef77d69cf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad76b024129e3e74a6e15e87f91a464ae"><td class="memItemLeft" align="right" valign="top">SIM_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gad76b024129e3e74a6e15e87f91a464ae">opp_dtoa</a> (char *buf, const char *format, double d)</td></tr>
<tr class="memdesc:gad76b024129e3e74a6e15e87f91a464ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the d double into the given buffer, then returns the buffer pointer. If d is finite, the given printf format is used (e.g. "%g"), otherwise it prints "inf", "-inf" or "nan". (Note that printf's handling of NaN and infinity is platform-dependent, e.g. MSVC produces "1.#QNAN" and "1.#INF".)  <a href="group__StringFunctions.html#gad76b024129e3e74a6e15e87f91a464ae">More...</a><br /></td></tr>
<tr class="separator:gad76b024129e3e74a6e15e87f91a464ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb28e927f34be18f0e4db7acac616ef9"><td class="memItemLeft" align="right" valign="top">SIM_API long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gafb28e927f34be18f0e4db7acac616ef9">opp_strtol</a> (const char *s, char **endptr)</td></tr>
<tr class="memdesc:gafb28e927f34be18f0e4db7acac616ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the standard strtol(), but throws opp_runtime_error if an overflow occurs during conversion. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal).  <a href="group__StringFunctions.html#gafb28e927f34be18f0e4db7acac616ef9">More...</a><br /></td></tr>
<tr class="separator:gafb28e927f34be18f0e4db7acac616ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga150b3387177ebddcb793d70fe573d5f6"><td class="memItemLeft" align="right" valign="top">SIM_API long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga150b3387177ebddcb793d70fe573d5f6">opp_atol</a> (const char *s)</td></tr>
<tr class="memdesc:ga150b3387177ebddcb793d70fe573d5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the standard atol(), but throws opp_runtime_error if an overflow occurs during conversion, or if there is (non-whitespace) trailing garbage after the number. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal).  <a href="group__StringFunctions.html#ga150b3387177ebddcb793d70fe573d5f6">More...</a><br /></td></tr>
<tr class="separator:ga150b3387177ebddcb793d70fe573d5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15c4bad2c510cbf0ec041a424e9db029"><td class="memItemLeft" align="right" valign="top">SIM_API unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga15c4bad2c510cbf0ec041a424e9db029">opp_strtoul</a> (const char *s, char **endptr)</td></tr>
<tr class="memdesc:ga15c4bad2c510cbf0ec041a424e9db029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the standard strtoul(), but throws opp_runtime_error if an overflow occurs during conversion. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal).  <a href="group__StringFunctions.html#ga15c4bad2c510cbf0ec041a424e9db029">More...</a><br /></td></tr>
<tr class="separator:ga15c4bad2c510cbf0ec041a424e9db029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b6a00858afa29b12e74e1c003bc99cb"><td class="memItemLeft" align="right" valign="top">SIM_API unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga7b6a00858afa29b12e74e1c003bc99cb">opp_atoul</a> (const char *s)</td></tr>
<tr class="memdesc:ga7b6a00858afa29b12e74e1c003bc99cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the standard atol(), but for unsigned long, and throws opp_runtime_error if an overflow occurs during conversion, or if there is (non-whitespace) trailing garbage after the number. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal).  <a href="group__StringFunctions.html#ga7b6a00858afa29b12e74e1c003bc99cb">More...</a><br /></td></tr>
<tr class="separator:ga7b6a00858afa29b12e74e1c003bc99cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b4cce33788e0250b33bd6a640c74c04"><td class="memItemLeft" align="right" valign="top">SIM_API long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga5b4cce33788e0250b33bd6a640c74c04">opp_strtoll</a> (const char *s, char **endptr)</td></tr>
<tr class="memdesc:ga5b4cce33788e0250b33bd6a640c74c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the standard strtoll(), but throws opp_runtime_error if an overflow occurs during conversion. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal).  <a href="group__StringFunctions.html#ga5b4cce33788e0250b33bd6a640c74c04">More...</a><br /></td></tr>
<tr class="separator:ga5b4cce33788e0250b33bd6a640c74c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4b5636a96655dda8e7b68d91312ea0"><td class="memItemLeft" align="right" valign="top">SIM_API long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga6d4b5636a96655dda8e7b68d91312ea0">opp_atoll</a> (const char *s)</td></tr>
<tr class="memdesc:ga6d4b5636a96655dda8e7b68d91312ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the standard atoll(), but throws opp_runtime_error if an overflow occurs during conversion, or if there is (non-whitespace) trailing garbage after the number. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal).  <a href="group__StringFunctions.html#ga6d4b5636a96655dda8e7b68d91312ea0">More...</a><br /></td></tr>
<tr class="separator:ga6d4b5636a96655dda8e7b68d91312ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c87a27f997feb19385ea80aa432205f"><td class="memItemLeft" align="right" valign="top">SIM_API unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga1c87a27f997feb19385ea80aa432205f">opp_strtoull</a> (const char *s, char **endptr)</td></tr>
<tr class="memdesc:ga1c87a27f997feb19385ea80aa432205f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the standard strtoull(), but throws opp_runtime_error if an overflow occurs during conversion. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal).  <a href="group__StringFunctions.html#ga1c87a27f997feb19385ea80aa432205f">More...</a><br /></td></tr>
<tr class="separator:ga1c87a27f997feb19385ea80aa432205f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ad2287b227a9e43f1548540f6799c66"><td class="memItemLeft" align="right" valign="top">SIM_API unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga8ad2287b227a9e43f1548540f6799c66">opp_atoull</a> (const char *s)</td></tr>
<tr class="memdesc:ga8ad2287b227a9e43f1548540f6799c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the standard atoull(), but throws opp_runtime_error if an overflow occurs during conversion, or if there is (non-whitespace) trailing garbage after the number. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal).  <a href="group__StringFunctions.html#ga8ad2287b227a9e43f1548540f6799c66">More...</a><br /></td></tr>
<tr class="separator:ga8ad2287b227a9e43f1548540f6799c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80e58230efebb5ee867e1dfe00065a6"><td class="memItemLeft" align="right" valign="top">SIM_API double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#gaa80e58230efebb5ee867e1dfe00065a6">opp_strtod</a> (const char *s, char **endptr)</td></tr>
<tr class="memdesc:gaa80e58230efebb5ee867e1dfe00065a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the standard strtod(), but throws opp_runtime_error if an overflow occurs during conversion.  <a href="group__StringFunctions.html#gaa80e58230efebb5ee867e1dfe00065a6">More...</a><br /></td></tr>
<tr class="separator:gaa80e58230efebb5ee867e1dfe00065a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ccbccea824acf966874bbe812f4e78b"><td class="memItemLeft" align="right" valign="top">SIM_API double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StringFunctions.html#ga8ccbccea824acf966874bbe812f4e78b">opp_atof</a> (const char *s)</td></tr>
<tr class="memdesc:ga8ccbccea824acf966874bbe812f4e78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the standard atof(), but throws opp_runtime_error if an overflow occurs during conversion, or if there is (non-whitespace) trailing garbage after the number.  <a href="group__StringFunctions.html#ga8ccbccea824acf966874bbe812f4e78b">More...</a><br /></td></tr>
<tr class="separator:ga8ccbccea824acf966874bbe812f4e78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad71987187ec298ccaf34333675ff51e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad71987187ec298ccaf34333675ff51e8">&#9670;&nbsp;</a></span>opp_isempty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool omnetpp::opp_isempty </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the string is nullptr or has zero length. </p>

<p class="reference">Referenced by <a class="el" href="group__StringFunctions.html#ga6e5c4983b9967fe2ddcac3d2e4455d3a">omnetpp::opp_emptytodefault()</a>.</p>

</div>
</div>
<a id="ga951c9575f8fe8e4db1b42a27ae0c0094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga951c9575f8fe8e4db1b42a27ae0c0094">&#9670;&nbsp;</a></span>opp_nulltoempty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* omnetpp::opp_nulltoempty </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointer passed as argument unchanged, except that if it was nullptr, it returns a pointer to a null string (""). </p>

</div>
</div>
<a id="ga6e5c4983b9967fe2ddcac3d2e4455d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e5c4983b9967fe2ddcac3d2e4455d3a">&#9670;&nbsp;</a></span>opp_emptytodefault()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* omnetpp::opp_emptytodefault </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defaultString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointer passed as argument unchanged, except that if it was empty, it returns the second argument. </p>

<p class="reference">References <a class="el" href="group__StringFunctions.html#gad71987187ec298ccaf34333675ff51e8">omnetpp::opp_isempty()</a>.</p>

</div>
</div>
<a id="gadbe853f05a2e0646a92dee806ec7e5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbe853f05a2e0646a92dee806ec7e5ad">&#9670;&nbsp;</a></span>opp_isblank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API bool omnetpp::opp_isblank </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>txt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the string only contains whitespace. </p>

</div>
</div>
<a id="gac5d37626062f2bb2cf6aa6395c0b03f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5d37626062f2bb2cf6aa6395c0b03f5">&#9670;&nbsp;</a></span>opp_strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int omnetpp::opp_strlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the standard strlen() function, except that does not crash on nullptr but returns 0. </p>

</div>
</div>
<a id="ga952348557633594f6aafefb765e903b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga952348557633594f6aafefb765e903b8">&#9670;&nbsp;</a></span>opp_strdup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* omnetpp::opp_strdup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicates the string, using <code>new char[]</code>. For nullptr and empty strings it returns nullptr. </p>

<p class="reference">Referenced by <a class="el" href="classomnetpp_1_1opp__string.html#a84534ecb0bfb413a88ed782fa2cdfaf6">opp_string::operator=()</a>, and <a class="el" href="classomnetpp_1_1opp__string.html#a4242ceb0bdc72550ef4bcf02f1682df5">opp_string::opp_string()</a>.</p>

</div>
</div>
<a id="ga2a17c1ab20b3f51d5d9161390addc7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a17c1ab20b3f51d5d9161390addc7a8">&#9670;&nbsp;</a></span>opp_strcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* omnetpp::opp_strcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the standard strcpy() function, except that nullptr in the second argument is treated as a pointer to an empty string (""). </p>

</div>
</div>
<a id="gac7992873d177e68c338886da35078781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7992873d177e68c338886da35078781">&#9670;&nbsp;</a></span>opp_strcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int omnetpp::opp_strcmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the standard strcmp() function, except that nullptr is treated exactly as an empty string (""). </p>

<p class="reference">Referenced by <a class="el" href="classomnetpp_1_1opp__string.html#a39a932f2ac073af31ffdb2c7469c2ed8">opp_string::operator!=()</a>, <a class="el" href="classomnetpp_1_1opp__string.html#a532a46694e54c770fd734fec962e3c19">opp_string::operator&lt;()</a>, and <a class="el" href="classomnetpp_1_1opp__string.html#ae3202a6e72d5cc6568d871b1b7a06bc6">opp_string::operator==()</a>.</p>

</div>
</div>
<a id="ga735e27c5ec595ea46855842d1ed82966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga735e27c5ec595ea46855842d1ed82966">&#9670;&nbsp;</a></span>opp_trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes any leading and trailing whitespace. </p>

</div>
</div>
<a id="ga46437ddb528048851ff78a55fda7fd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46437ddb528048851ff78a55fda7fd0b">&#9670;&nbsp;</a></span>opp_strprettytrunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API char* omnetpp::opp_strprettytrunc </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies src string into dest, and if its length would exceed maxlen, it is truncated with an ellipsis. For example, <code>opp_strprettytrunc(buf, "long-long",6)</code> yields <code>"lon..."</code>. </p>

</div>
</div>
<a id="ga6dacc92d54b7cbafad7ca28759f847e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dacc92d54b7cbafad7ca28759f847e3">&#9670;&nbsp;</a></span>opp_stringf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_stringf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a string using printf-like formatting. Allocates storage dynamically. </p>

</div>
</div>
<a id="ga66e6cf98a49b9081da46c90ec6dc0bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66e6cf98a49b9081da46c90ec6dc0bf7">&#9670;&nbsp;</a></span>opp_vstringf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_vstringf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a string using printf-like formatting. Allocates storage dynamically. </p>

</div>
</div>
<a id="ga9e2c73bb1375dd511c9049f8d34b6583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e2c73bb1375dd511c9049f8d34b6583">&#9670;&nbsp;</a></span>opp_replacesubstring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_replacesubstring </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>substring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceAll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs find/replace within a string. </p>

</div>
</div>
<a id="gaab32c96ea56086b02c1b7d8e4b8ec6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab32c96ea56086b02c1b7d8e4b8ec6d0">&#9670;&nbsp;</a></span>opp_splitandtrim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::vector&lt;std::string&gt; omnetpp::opp_splitandtrim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into parts by whitespace sequences. Returned items will have no leading or trailing whitespace. Returns an empty array if the input string is empty or only contains whitespace. </p>

</div>
</div>
<a id="gab4cf0fbabebf36ca6b42e21c2df0c256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4cf0fbabebf36ca6b42e21c2df0c256">&#9670;&nbsp;</a></span>opp_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::vector&lt;std::string&gt; omnetpp::opp_split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into parts separated by the given separator. If the input string is empty, it returns an empty array. Otherwise, it returns exactly #separators+1 items. The separator cannot be empty. </p>

</div>
</div>
<a id="ga182ca639f566554f9f3ad569db526f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga182ca639f566554f9f3ad569db526f16">&#9670;&nbsp;</a></span>opp_splitandtrim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::vector&lt;std::string&gt; omnetpp::opp_splitandtrim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into parts separated by the given separator, trimming each item of whitespace. Returns an empty array if the input string doesn't contain anything but whitespace. The separator cannot be empty. </p>

</div>
</div>
<a id="ga6906bf6d09624b52903983a729c94384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6906bf6d09624b52903983a729c94384">&#9670;&nbsp;</a></span>opp_stringbeginswith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API bool omnetpp::opp_stringbeginswith </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the first string begins with the second string. </p>

</div>
</div>
<a id="gaa4bcbc00e314d5e89f471f9b81ee56d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4bcbc00e314d5e89f471f9b81ee56d3">&#9670;&nbsp;</a></span>opp_stringendswith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API bool omnetpp::opp_stringendswith </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the first string ends in the second string. </p>

</div>
</div>
<a id="ga0b0e66b1e0b0b1d9c307af789581c0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b0e66b1e0b0b1d9c307af789581c0cc">&#9670;&nbsp;</a></span>opp_substringbefore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_substringbefore </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the substring up to the first occurrence of the given substring, or "". </p>

</div>
</div>
<a id="ga8654572f4cc9b5503ad8a9c0262c28ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8654572f4cc9b5503ad8a9c0262c28ba">&#9670;&nbsp;</a></span>opp_substringafter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_substringafter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the substring after the first occurrence of the given substring, or "". </p>

</div>
</div>
<a id="ga2d2f9943819c4a05d300f20a6bba4942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d2f9943819c4a05d300f20a6bba4942">&#9670;&nbsp;</a></span>opp_substringbeforelast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_substringbeforelast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the substring up to the last occurrence of the given substring, or "". </p>

</div>
</div>
<a id="gacef29cbc82992df1f61fc81584c9a534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacef29cbc82992df1f61fc81584c9a534">&#9670;&nbsp;</a></span>opp_substringafterlast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_substringafterlast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>substr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the substring after the last occurrence of the given substring, or "". </p>

</div>
</div>
<a id="gaf6a0bc1a9a28acb13bfcfc72497804d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6a0bc1a9a28acb13bfcfc72497804d8">&#9670;&nbsp;</a></span>opp_removestart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_removestart </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the prefix if the s string starts with it, otherwise return the string unchanged. </p>

</div>
</div>
<a id="ga7c866b0a1188f316c80fa86c1d85e466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c866b0a1188f316c80fa86c1d85e466">&#9670;&nbsp;</a></span>opp_removeend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_removeend </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the given end string if the s string ends with it, otherwise return the string unchanged. </p>

</div>
</div>
<a id="ga903130ddaf3e5c86b7dba1cb3bbfc69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga903130ddaf3e5c86b7dba1cb3bbfc69b">&#9670;&nbsp;</a></span>opp_strlower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_strlower </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the string to lower case, and returns the result. </p>

</div>
</div>
<a id="gadffe270826254f3958a942d619c20f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadffe270826254f3958a942d619c20f2f">&#9670;&nbsp;</a></span>opp_strupper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_strupper </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the string to upper case, and returns the result. </p>

</div>
</div>
<a id="gad9a82ab8007ff491ef98f4022bd927b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9a82ab8007ff491ef98f4022bd927b8">&#9670;&nbsp;</a></span>opp_strnistr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const SIM_API char* omnetpp::opp_strnistr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>caseSensitive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locates the first occurrence of the nul-terminated string needle in the string haystack, where not more than n characters are searched. Characters that appear after a '\0' character are not searched. </p>

</div>
</div>
<a id="ga8d108163546bdfe10a30659151cc207e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d108163546bdfe10a30659151cc207e">&#9670;&nbsp;</a></span>opp_strdictcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API int omnetpp::opp_strdictcmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dictionary-compare two strings, the main difference from strcasecmp() being that integers embedded in the strings are compared in numerical order. </p>

</div>
</div>
<a id="ga890fa100e722c6fb0c2dac45027968ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga890fa100e722c6fb0c2dac45027968ce">&#9670;&nbsp;</a></span>opp_join() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_join </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If either s1 or s2 is empty, returns the other one, otherwise returns s1 + separator + s2. </p>

</div>
</div>
<a id="ga5b3b9fe744b5f706f499bb22cd3b57a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b3b9fe744b5f706f499bb22cd3b57a1">&#9670;&nbsp;</a></span>opp_join() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_join </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If either s1 or s2 is empty, returns the other one, otherwise returns s1 + separator + s2. </p>

</div>
</div>
<a id="ga10eade29b929be0303af7b71f065206e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10eade29b929be0303af7b71f065206e">&#9670;&nbsp;</a></span>opp_join() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_join </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipEmpty</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>quoteChar</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate the strings passed in the nullptr-terminated const char * array, using the given separator and putting each item between quoteChars unless it is '\0'. Empty elements are optionally skipped. </p>

</div>
</div>
<a id="gad1e741f43ea4c1fda8f239d42ff1a5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1e741f43ea4c1fda8f239d42ff1a5f9">&#9670;&nbsp;</a></span>opp_join() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_join </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipEmpty</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>quoteChar</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate the strings passed in the const char * array of size n, using the given separator and putting each item between quoteChars unless it is '\0'. Empty elements are optionally skipped. </p>

</div>
</div>
<a id="ga1ba29e0e1269a81a4a77c85efc28a4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ba29e0e1269a81a4a77c85efc28a4e5">&#9670;&nbsp;</a></span>opp_join() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API std::string omnetpp::opp_join </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipEmpty</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>quoteChar</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate the strings passed in the vector, using the given separator, and putting each item between quoteChars unless it is '\0'. Empty elements are optionally skipped. </p>

</div>
</div>
<a id="ga446dacb337a9e200679cc387d979f631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga446dacb337a9e200679cc387d979f631">&#9670;&nbsp;</a></span>opp_itoa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API char* omnetpp::opp_itoa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the d integer into the given buffer, then returns the buffer pointer. </p>

</div>
</div>
<a id="ga5a8c0b13abed297a5c8cb3f1145fa289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a8c0b13abed297a5c8cb3f1145fa289">&#9670;&nbsp;</a></span>opp_ltoa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API char* omnetpp::opp_ltoa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the d integer into the given buffer, then returns the buffer pointer. </p>

</div>
</div>
<a id="gab7667e67a1537e12c04dbef77d69cf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7667e67a1537e12c04dbef77d69cf5d">&#9670;&nbsp;</a></span>opp_i64toa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API char* omnetpp::opp_i64toa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the d integer into the given buffer, then returns the buffer pointer. </p>

</div>
</div>
<a id="gad76b024129e3e74a6e15e87f91a464ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad76b024129e3e74a6e15e87f91a464ae">&#9670;&nbsp;</a></span>opp_dtoa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API char* omnetpp::opp_dtoa </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the d double into the given buffer, then returns the buffer pointer. If d is finite, the given printf format is used (e.g. "%g"), otherwise it prints "inf", "-inf" or "nan". (Note that printf's handling of NaN and infinity is platform-dependent, e.g. MSVC produces "1.#QNAN" and "1.#INF".) </p>

</div>
</div>
<a id="gafb28e927f34be18f0e4db7acac616ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb28e927f34be18f0e4db7acac616ef9">&#9670;&nbsp;</a></span>opp_strtol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API long omnetpp::opp_strtol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like the standard strtol(), but throws opp_runtime_error if an overflow occurs during conversion. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal). </p>

</div>
</div>
<a id="ga150b3387177ebddcb793d70fe573d5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga150b3387177ebddcb793d70fe573d5f6">&#9670;&nbsp;</a></span>opp_atol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API long omnetpp::opp_atol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like the standard atol(), but throws opp_runtime_error if an overflow occurs during conversion, or if there is (non-whitespace) trailing garbage after the number. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal). </p>

</div>
</div>
<a id="ga15c4bad2c510cbf0ec041a424e9db029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15c4bad2c510cbf0ec041a424e9db029">&#9670;&nbsp;</a></span>opp_strtoul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API unsigned long omnetpp::opp_strtoul </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like the standard strtoul(), but throws opp_runtime_error if an overflow occurs during conversion. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal). </p>

</div>
</div>
<a id="ga7b6a00858afa29b12e74e1c003bc99cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b6a00858afa29b12e74e1c003bc99cb">&#9670;&nbsp;</a></span>opp_atoul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API unsigned long omnetpp::opp_atoul </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like the standard atol(), but for unsigned long, and throws opp_runtime_error if an overflow occurs during conversion, or if there is (non-whitespace) trailing garbage after the number. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal). </p>

</div>
</div>
<a id="ga5b4cce33788e0250b33bd6a640c74c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b4cce33788e0250b33bd6a640c74c04">&#9670;&nbsp;</a></span>opp_strtoll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API long long omnetpp::opp_strtoll </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like the standard strtoll(), but throws opp_runtime_error if an overflow occurs during conversion. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal). </p>

</div>
</div>
<a id="ga6d4b5636a96655dda8e7b68d91312ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d4b5636a96655dda8e7b68d91312ea0">&#9670;&nbsp;</a></span>opp_atoll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API long long omnetpp::opp_atoll </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like the standard atoll(), but throws opp_runtime_error if an overflow occurs during conversion, or if there is (non-whitespace) trailing garbage after the number. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal). </p>

</div>
</div>
<a id="ga1c87a27f997feb19385ea80aa432205f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c87a27f997feb19385ea80aa432205f">&#9670;&nbsp;</a></span>opp_strtoull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API unsigned long long omnetpp::opp_strtoull </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like the standard strtoull(), but throws opp_runtime_error if an overflow occurs during conversion. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal). </p>

</div>
</div>
<a id="ga8ad2287b227a9e43f1548540f6799c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ad2287b227a9e43f1548540f6799c66">&#9670;&nbsp;</a></span>opp_atoull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API unsigned long long omnetpp::opp_atoull </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like the standard atoull(), but throws opp_runtime_error if an overflow occurs during conversion, or if there is (non-whitespace) trailing garbage after the number. Accepts decimal and C-style hexadecimal notation, but not octal (leading zeroes are simply discarded and the number is interpreted as decimal). </p>

</div>
</div>
<a id="gaa80e58230efebb5ee867e1dfe00065a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa80e58230efebb5ee867e1dfe00065a6">&#9670;&nbsp;</a></span>opp_strtod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API double omnetpp::opp_strtod </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like the standard strtod(), but throws opp_runtime_error if an overflow occurs during conversion. </p>

</div>
</div>
<a id="ga8ccbccea824acf966874bbe812f4e78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ccbccea824acf966874bbe812f4e78b">&#9670;&nbsp;</a></span>opp_atof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API double omnetpp::opp_atof </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like the standard atof(), but throws opp_runtime_error if an overflow occurs during conversion, or if there is (non-whitespace) trailing garbage after the number. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 31 2022 13:45:32 for OMNeT++ Simulation Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
