<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OMNeT++ Simulation Library: Utility Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OMNeT++ Simulation Library
   &#160;<span id="projectnumber">6.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__UtilityFunctions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utility Functions</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>This group is a collection of miscellaneous utility functions. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5044f74639a1f5cd3701d438261a0407"><td class="memTemplParams" colspan="2">template&lt;class P , class T &gt; </td></tr>
<tr class="memitem:ga5044f74639a1f5cd3701d438261a0407"><td class="memTemplItemLeft" align="right" valign="top">P&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilityFunctions.html#ga5044f74639a1f5cd3701d438261a0407">check_and_cast</a> (T *p)</td></tr>
<tr class="memdesc:ga5044f74639a1f5cd3701d438261a0407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a pointer to the given pointer type P, and throw exception if fails.  <a href="group__UtilityFunctions.html#ga5044f74639a1f5cd3701d438261a0407">More...</a><br /></td></tr>
<tr class="separator:ga5044f74639a1f5cd3701d438261a0407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4782d0f87609e981435a9ac0c0fcb0"><td class="memTemplParams" colspan="2">template&lt;class P , class T &gt; </td></tr>
<tr class="memitem:ga0b4782d0f87609e981435a9ac0c0fcb0"><td class="memTemplItemLeft" align="right" valign="top">P&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilityFunctions.html#ga0b4782d0f87609e981435a9ac0c0fcb0">check_and_cast_nullable</a> (T *p)</td></tr>
<tr class="memdesc:ga0b4782d0f87609e981435a9ac0c0fcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of check_and_cast&lt;&gt;() that also allows nullptr as input.  <a href="group__UtilityFunctions.html#ga0b4782d0f87609e981435a9ac0c0fcb0">More...</a><br /></td></tr>
<tr class="separator:ga0b4782d0f87609e981435a9ac0c0fcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1513afb661c828b08c376cd0b753267"><td class="memTemplParams" colspan="2">template&lt;typename ToInt , typename FromInt &gt; </td></tr>
<tr class="memitem:gaa1513afb661c828b08c376cd0b753267"><td class="memTemplItemLeft" align="right" valign="top">ToInt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilityFunctions.html#gaa1513afb661c828b08c376cd0b753267">checked_int_cast</a> (FromInt x, const char *errmsg=nullptr)</td></tr>
<tr class="memdesc:gaa1513afb661c828b08c376cd0b753267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe integer cast: it throws an exception if in case of an overflow, i.e. when if the target type cannot represent the value in the source type. The errmsg argument will be used for the error message.  <a href="group__UtilityFunctions.html#gaa1513afb661c828b08c376cd0b753267">More...</a><br /></td></tr>
<tr class="separator:gaa1513afb661c828b08c376cd0b753267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab96ebab99c3498b3df027cad31d1d27"><td class="memTemplParams" colspan="2">template&lt;typename ToInt , typename FromInt &gt; </td></tr>
<tr class="memitem:gaab96ebab99c3498b3df027cad31d1d27"><td class="memTemplItemLeft" align="right" valign="top">ToInt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilityFunctions.html#gaab96ebab99c3498b3df027cad31d1d27">checked_int_cast</a> (FromInt x, const <a class="el" href="classomnetpp_1_1cObject.html">cObject</a> *context, const char *errmsg=nullptr)</td></tr>
<tr class="memdesc:gaab96ebab99c3498b3df027cad31d1d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe integer cast: it throws an exception if in case of an overflow, i.e. when if the target type cannot represent the value in the source type. The context and errmsg arguments will be used for the error message.  <a href="group__UtilityFunctions.html#gaab96ebab99c3498b3df027cad31d1d27">More...</a><br /></td></tr>
<tr class="separator:gaab96ebab99c3498b3df027cad31d1d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ee410c4efb62be0d078da9fa0a15c91"><td class="memTemplParams" colspan="2">template&lt;typename ToInt &gt; </td></tr>
<tr class="memitem:ga6ee410c4efb62be0d078da9fa0a15c91"><td class="memTemplItemLeft" align="right" valign="top">ToInt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilityFunctions.html#ga6ee410c4efb62be0d078da9fa0a15c91">checked_int_cast</a> (double d, const char *errmsg=nullptr)</td></tr>
<tr class="memdesc:ga6ee410c4efb62be0d078da9fa0a15c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe integer cast: it throws an exception if in case of an overflow, i.e. when if the target type cannot represent the value in the source type. The errmsg argument will be used for the error message.  <a href="group__UtilityFunctions.html#ga6ee410c4efb62be0d078da9fa0a15c91">More...</a><br /></td></tr>
<tr class="separator:ga6ee410c4efb62be0d078da9fa0a15c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac84f049f10908f73605a9793e14cc4a2"><td class="memItemLeft" align="right" valign="top">const SIM_API char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilityFunctions.html#gac84f049f10908f73605a9793e14cc4a2">opp_typename</a> (const std::type_info &amp;t)</td></tr>
<tr class="memdesc:gac84f049f10908f73605a9793e14cc4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of a C++ type, correcting the quirks of various compilers.  <a href="group__UtilityFunctions.html#gac84f049f10908f73605a9793e14cc4a2">More...</a><br /></td></tr>
<tr class="separator:gac84f049f10908f73605a9793e14cc4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga699107b48aeac4f768b6edf9d4b7b1b5"><td class="memItemLeft" align="right" valign="top">SIM_API int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilityFunctions.html#ga699107b48aeac4f768b6edf9d4b7b1b5">opp_get_monotonic_clock_nsecs</a> ()</td></tr>
<tr class="memdesc:ga699107b48aeac4f768b6edf9d4b7b1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a monotonic time in nanoseconds since some unspecified starting point. This clock is not affected by discontinuous jumps in the system time (e.g. if the system administrator manually changes the clock). Note that the actual resolution (precision) of the clock may be less than nanoseconds.  <a href="group__UtilityFunctions.html#ga699107b48aeac4f768b6edf9d4b7b1b5">More...</a><br /></td></tr>
<tr class="separator:ga699107b48aeac4f768b6edf9d4b7b1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga891c0be14175481589952eda25a9607f"><td class="memItemLeft" align="right" valign="top">SIM_API int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilityFunctions.html#ga891c0be14175481589952eda25a9607f">opp_get_monotonic_clock_usecs</a> ()</td></tr>
<tr class="memdesc:ga891c0be14175481589952eda25a9607f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a monotonic time in microseconds since some unspecified starting point. This clock is not affected by discontinuous jumps in the system time (e.g. if the system administrator manually changes the clock). Note that the actual resolution (precision) of the clock may be less than microseconds.  <a href="group__UtilityFunctions.html#ga891c0be14175481589952eda25a9607f">More...</a><br /></td></tr>
<tr class="separator:ga891c0be14175481589952eda25a9607f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5044f74639a1f5cd3701d438261a0407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5044f74639a1f5cd3701d438261a0407">&#9670;&nbsp;</a></span>check_and_cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">P omnetpp::check_and_cast </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast a pointer to the given pointer type P, and throw exception if fails. </p>
<p>The method calls dynamic_cast&lt;P&gt;(p) where P is a type you supplied; if the result is nullptr (which indicates incompatible types), an exception is thrown.</p>
<p>In the following example, DHCPPacket is a subclass of <a class="el" href="classomnetpp_1_1cMessage.html" title="The message class in OMNeT++. cMessage objects may represent events, messages, jobs or other entities...">cMessage</a>, and we want to assert that the message received is actually a DHCPPacket. If not, the simulation stops with an error message as the result of the exception. </p><pre>
  <a class="el" href="classomnetpp_1_1cMessage.html" title="The message class in OMNeT++. cMessage objects may represent events, messages, jobs or other entities...">cMessage</a> *msg = ...;
  DHCPPacket *pk = check_and_cast&lt;DHCPPacket *&gt;(msg);
</pre> 
<p class="reference">References <a class="el" href="group__UtilityFunctions.html#gac84f049f10908f73605a9793e14cc4a2">omnetpp::opp_typename()</a>.</p>

</div>
</div>
<a id="ga0b4782d0f87609e981435a9ac0c0fcb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b4782d0f87609e981435a9ac0c0fcb0">&#9670;&nbsp;</a></span>check_and_cast_nullable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">P omnetpp::check_and_cast_nullable </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variant of check_and_cast&lt;&gt;() that also allows nullptr as input. </p>

</div>
</div>
<a id="gaa1513afb661c828b08c376cd0b753267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1513afb661c828b08c376cd0b753267">&#9670;&nbsp;</a></span>checked_int_cast() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ToInt omnetpp::checked_int_cast </td>
          <td>(</td>
          <td class="paramtype">FromInt&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>errmsg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe integer cast: it throws an exception if in case of an overflow, i.e. when if the target type cannot represent the value in the source type. The errmsg argument will be used for the error message. </p>

</div>
</div>
<a id="gaab96ebab99c3498b3df027cad31d1d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab96ebab99c3498b3df027cad31d1d27">&#9670;&nbsp;</a></span>checked_int_cast() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ToInt omnetpp::checked_int_cast </td>
          <td>(</td>
          <td class="paramtype">FromInt&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classomnetpp_1_1cObject.html">cObject</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>errmsg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe integer cast: it throws an exception if in case of an overflow, i.e. when if the target type cannot represent the value in the source type. The context and errmsg arguments will be used for the error message. </p>

</div>
</div>
<a id="ga6ee410c4efb62be0d078da9fa0a15c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ee410c4efb62be0d078da9fa0a15c91">&#9670;&nbsp;</a></span>checked_int_cast() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ToInt omnetpp::checked_int_cast </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>errmsg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe integer cast: it throws an exception if in case of an overflow, i.e. when if the target type cannot represent the value in the source type. The errmsg argument will be used for the error message. </p>

</div>
</div>
<a id="gac84f049f10908f73605a9793e14cc4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac84f049f10908f73605a9793e14cc4a2">&#9670;&nbsp;</a></span>opp_typename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const SIM_API char* omnetpp::opp_typename </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of a C++ type, correcting the quirks of various compilers. </p>

<p class="reference">Referenced by <a class="el" href="classomnetpp_1_1cValueArray.html#af8d1f2fada83c352576206b52806fb60">cValueArray::asObjectVector()</a>, <a class="el" href="group__UtilityFunctions.html#ga5044f74639a1f5cd3701d438261a0407">omnetpp::check_and_cast()</a>, <a class="el" href="classomnetpp_1_1cGenericReadonlyWatch.html#aa0d8ddf8e340589ce5a4ebdc1d5e070d">cGenericReadonlyWatch&lt; T &gt;::getClassName()</a>, and <a class="el" href="classomnetpp_1_1cGenericAssignableWatch.html#aa0d8ddf8e340589ce5a4ebdc1d5e070d">cGenericAssignableWatch&lt; T &gt;::getClassName()</a>.</p>

</div>
</div>
<a id="ga699107b48aeac4f768b6edf9d4b7b1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga699107b48aeac4f768b6edf9d4b7b1b5">&#9670;&nbsp;</a></span>opp_get_monotonic_clock_nsecs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API int64_t omnetpp::opp_get_monotonic_clock_nsecs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a monotonic time in nanoseconds since some unspecified starting point. This clock is not affected by discontinuous jumps in the system time (e.g. if the system administrator manually changes the clock). Note that the actual resolution (precision) of the clock may be less than nanoseconds. </p>

</div>
</div>
<a id="ga891c0be14175481589952eda25a9607f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga891c0be14175481589952eda25a9607f">&#9670;&nbsp;</a></span>opp_get_monotonic_clock_usecs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIM_API int64_t omnetpp::opp_get_monotonic_clock_usecs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a monotonic time in microseconds since some unspecified starting point. This clock is not affected by discontinuous jumps in the system time (e.g. if the system administrator manually changes the clock). Note that the actual resolution (precision) of the clock may be less than microseconds. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 31 2022 13:45:32 for OMNeT++ Simulation Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
